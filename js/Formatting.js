// Generated by CoffeeScript 1.12.4
var NEWLINE, StrictMap, Type, emptyFunction, isNodeJS, isType, repeatString, replace, steal, sync, type;

emptyFunction = require("emptyFunction");

repeatString = require("repeat-string");

StrictMap = require("StrictMap");

isNodeJS = require("isNodeJS");

replace = require("replace");

isType = require("isType");

steal = require("steal");

Type = require("Type");

sync = require("sync");

NEWLINE = isNodeJS ? require("os").EOL : "\n";

type = Type("Formatting");

type.inherits(StrictMap);

type.createInstance((function() {
  var propDefaults, propTypes;
  propTypes = {
    maxStringLength: Number,
    maxObjectDepth: Number,
    maxObjectKeys: Number,
    maxArrayKeys: Number,
    showInherited: Boolean,
    showHidden: Boolean
  };
  propDefaults = {
    maxStringLength: 60,
    maxObjectDepth: 2,
    maxObjectKeys: 30,
    maxArrayKeys: 10,
    showInherited: false,
    showHidden: false
  };
  return function() {
    return StrictMap(propTypes).update(propDefaults);
  };
})());

type.defineArgs({
  colors: Boolean.or(Object),
  compact: Boolean,
  collapse: Function,
  unlimited: Boolean,
  avoidGetters: Boolean
});

type.defineValues(function(options) {
  return {
    ln: NEWLINE,
    depth: 0,
    keyPath: "",
    compact: steal(options, "compact", false),
    collapse: steal(options, "collapse", emptyFunction.thatReturnsFalse),
    avoidGetters: steal(options, "avoidGetters", false),
    _parts: [],
    _isIndented: false
  };
});

type.defineFrozenValues(function(options) {
  return {
    keyPaths: [],
    objects: [],
    _colors: steal(options, "colors")
  };
});

type.initInstance(function(options) {
  if (steal(options, "unlimited")) {
    options.maxStringLength = 2e308;
    options.maxObjectDepth = 2e308;
    options.maxObjectKeys = 2e308;
    options.maxArrayKeys = 2e308;
  }
  this.update(options);
});

type.defineMethods({
  push: function(style, message) {
    var applyStyle, styles;
    if (arguments.length === 1) {
      message = style;
      style = null;
    } else if (this._colors && isType(style, String)) {
      styles = style.split(".");
      applyStyle = sync.reduce(styles, this._colors, function(style, key) {
        return style[key];
      });
      message = applyStyle(message);
    }
    if (!this.compact) {
      if (message === NEWLINE) {
        this._isIndented = false;
      } else if (this.depth && !this._isIndented) {
        this._isIndented = true;
        message = repeatString("  ", this.depth) + message;
      }
    }
    this._parts.push(message);
  },
  flush: function() {
    return replace(this, "_parts", []);
  }
});

module.exports = type.build();
